# 树

## 二叉树

### 二叉树的定义

二叉树的每个结点至多只有二棵子树(不存在度大于 2 的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 $2^{i-1}$ 个结点；深度为 k 的二叉树至多有 $2^{i-1}$ 个结点；对任何一棵二叉树 T，如果其终端结点数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0=n_2+1$

### 满二叉树

除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

满二叉树的性质：

1. 一颗树深度为 h，最大层数为 k，深度与最大层数相同，k=h;
2. 叶子数为 $2^h$;
3. 第 k 层的结点数是：$2^{k-1}$;
4. 总结点数是：$2^{k-1}$，且总节点数一定是奇数。

### 完全二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层 (1 ～(h-1)层) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra 算法、Prim 算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

### 二叉树的性质

1. 在非空二叉树中，第 i 层的结点总数不超过 $2^{i-1}$, 其中 $i\geq 1$;
2. 深度为 h 的二叉树最多有 $2^{h-1}$ 个结点($h\geq 1$)，最少有 h 个结点;
3. 对于任意一棵二叉树，如果其叶结点数为 $N_0$，而度数为 2 的结点总数为 $N_2$，则 $N_0=N_2+1$;
4. 具有 n 个结点的完全二叉树的深度为 $log_2(n+1)$;
5. 有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：
   - 若 I 为结点编号则 如果 $I>1$，则其父结点的编号为 $I/2$；
   - 如果 $2I \leq N$，则其左儿子（即左子树的根结点）的编号为 2I；若 2I>N，则无左儿子；
   - 如果 $2I+1\leq N$，则其右儿子的结点编号为 $2I+1$；若 $2I+1>N$，则无右儿子。
6. 给定 N 个节点，能构成 $h(N)$种不同的二叉树，其中 $h(N)$为卡特兰数的第 N 项，$h(n)=C(2*n, n)/(n+1)$。
7. 设有 i 个枝点，I 为所有枝点的道路长度总和，J 为叶的道路长度总和 $J=I+2^i$。

## 二叉查找树

二叉查找树又称二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
3. 左、右子树也分别为二叉排序树；
4. 没有键值相等的节点。

### 二叉查找树的性质

对二叉查找树进行中序遍历，即可得到有序的数列。
二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为 O($log_n$)，但是在最坏的情况下仍然会有 O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行 n 次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。
二叉查找树的高度决定了二叉查找树的查找效率。
二叉查找树的插入过程如下：

1. 若当前的二叉查找树为空，则插入的元素为根节点;
2. 若插入的元素值小于根节点值，则将元素插入到左子树中;
3. 若插入的元素值不小于根节点值，则将元素插入到右子树中。

二叉查找树的删除，分三种情况进行处理：

1. p 为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图 a;
2. p 为单支节点（即只有左子树或右子树）。让 p 的子树与 p 的父亲节点相连，删除 p 即可（注意分是根节点和不是根节点），如图 b;
3. p 的左子树和右子树均不空。找到 p 的后继 y，因为 y 一定没有左子树，所以可以删除 y，并让 y 的父亲节点成为 y 的右子树的父亲节点，并用 y 的值代替 p 的值；或者方法二是找到 p 的前驱 x，x 一定没有右子树，所以可以删除 x，并让 x 的父亲节点成为 y 的左子树的父亲节点。如图 c。

## 平衡二叉树

我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为 log2n，其各操作的时间复杂度 O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。

平衡二叉树（Balanced Binary Tree）又被称为 AVL 树（有别于 AVL 算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL 树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在 O(log2n)，大大降低了操作的时间复杂度。

最小二叉平衡树的节点的公式如下：

$F(n)=F(n-1)+F(n-2)+1$

这个类似于一个递归的数列，可以参考 Fibonacci 数列，1 是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。

## 红黑树

## 2-3 树

## B 树

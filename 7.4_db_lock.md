## 数据库锁

#### 锁的分类

| 锁模式分类 | 乐观锁                 |
| ---------- | ---------------------- |
| 范围锁     | 行锁、表锁             |
| 算法锁     | 临间锁、间隙锁、记录锁 |
| 属性锁     | 共享锁、排他锁         |
| 状态锁     | 单身共享锁、单身排他锁 |

~~~mermaid
graph LR
lock[锁] -->optimistic[乐观锁]
	lock --> passive[悲观锁]
    	passive --> range[范围锁]
    		range --> table[表锁]
    		range --> row[行锁]
    			row --> record[记录锁]
    			row --> cap[间隙锁]
    			row --> neighor[临间锁]
    	passive --> property[属性锁]
    		property --> share[共享锁]
    		property --> exclusion[排它锁]
    	passive --> state[状态锁]
    		state --> mind-share[意向共享锁]
    		state --> mind-exclusion[意向排它锁]

~~~

#### MySQL都有什么锁，死锁判定原理和具体场景，死锁怎么解决

MySQL 有有一种级别的锁：页级、表级、行级

| 种类   | 优缺点                                                       |
| ------ | ------------------------------------------------------------ |
| 表级锁 | 开销小，加锁快，不会出现死锁，锁定数度大，发生锁冲突的概率最高，并发度最低 |
| 行级锁 | 开销大，加锁慢，会出现死锁，锁定数度最小，发生锁冲突的概率最低，并发度也最高 |
| 页面锁 | 开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般 |

#### 什么是死锁

死锁是指两个或两个以上的进程在执行进程中。因争夺资源面造成的一种互相等待的现象，苦无外力作用，它们都将无法推进下去。此时称系统牌死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁

#### 悲观锁

对于并发执行可能冲突的操作，假定其必定发生冲突，通过让事务等待（锁）或者中止（时间戳排序）的方式使并行的操作串行执行。

先获取锁，再进行业务操作，即“悲观”地认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。

通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的 select ... for update 操作来实现悲观锁。当数据库执行 select for update 时会获取被 select 中的数据行的行锁，因此其他并发执行的 select for update 如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update 获取的行锁会在当前事务结束时释放，因此必须在事务中使用。

补充：

不同数据库对 select for update 的实现和支持都是有所区别的

- Oracle 支持 select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL 不支持 no wait 选项。
- MySQL 还有个问题是 select for update 语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必确定使用了索引，而不是全表扫描。

#### 乐观锁（Optimistic Lock）

对于并发执行可能冲突的操作，假定其不会真的冲突，允许并发执行，直到真正发生冲突时才去解决冲突，比如让事务回滚。

乐观锁的特点，先进行业务操作，不到万不得已不去拿锁。即“乐观”地认为拿锁多半会是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。

乐观锁中数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。

一般的做法是在需要锁的数据上增加一个版本号，或者时间戳。

##### 注意：

给表加一个版本号并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种实现方式

#### 有哪些锁（悲观锁和乐观锁），select 时怎么加排它锁

悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例如在 select ... for update 前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。

- 响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就所选，不成功就失败，不需要等待其他并发去释放锁。
- 冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。
  重试代价：如果重试代价大，建议采用悲观锁。

#### 共享锁与互斥锁

共享锁：如果事务对数据加上共享锁后，则其他事务只能对该数据再加共享锁，不能加排他锁。获取共享锁的事务只能对数据作只读操作。

揍他锁：如果事务对数据加上揍他锁后，则其他事务不能再对该数据加任何类型的锁。获取揍他锁的事务只能对数据作只读操作。

#### 悲观锁的实现

- 1、基于共享锁与揍他锁，控制并发流程。
- 2、基于时间戳排序规则选定某事务继续执行，其他事务回滚。

#### 乐观锁的实现

* 1、有效性检查

  事务对数据的更新首先在自己的工作空间进行，等到要写回数据库时才进行有效性检查，对不符合要求的事务进行回滚。

* 2、快照隔离

  数据库为每个数据项维护多个版本（快照），每个事务只对属于自己的私有快照进行更新，在事务真正提交前进行有效性检查，使得事务正常提交更新或者失败回滚。
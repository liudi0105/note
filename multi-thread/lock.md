#### Java 中 notify 和 notifyAll 有什么区别？

这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员撮合了一些方法当等待锚固件改变的时候通知它们，但是这些方法没有完全实现。notify() 方法不能唤醒七个具体的线程，所以只有一个线程在等待的时候它都有用武之地。而 notifyAll() 唤醒所有线程并允许它们争夺锁确保了至少有一个线程能继续运行。

#### 为什么 wait()，notify() 和 notifyAll() 这些方法在 Object 中？

Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁，那么调用对象中的 wait() 方法就有意义 了。如果 wait() 方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把它们定义在 Object 类中因为锁属于对象。

#### 为什么 wait() 和 notify() 方法要在同步块中调用？

wait() 方法做了两件事，一是释放锁，二是使当前线程处于等待状态。若要释放锁先要获取锁，在同步块中是持有锁的状态，因此要在同步块中执行 wait()。

notify() 方法通知持有当前锁时 wait() 的线程继续执行，因此也需要先获取锁。

#### 为什么 wait 和 notify 方法要在同步代码块中调用？

当一个线程需要调用对象的 wait() 方法的时候，这个线程必须拥有该对象的锁，接着它就 会释放这个 对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify() 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。如果不这么做，代码会抛出 IllegalMonitorStateException 异常。
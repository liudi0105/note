# 面向对象

#### 什么是面向过程与面向对象

面向过程：把问题分解成一个一个步骤，依次按先后顺序执行，最终得到结果

面向对象：把解决一个问题相关的数据和处理这些数据操作封集成到一个对象（object），把相同行为的对象归纳为类(class)，通过类的封闭（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）/泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。

#### 面向对象的三个基本特征

面向对象的三个基本特征是：封装、继承、多态

**封装**

定义：封装就是把客观事务封装成抽象的类，并且类可以把自己的数据和方法只让可信的对象操作，对不可信的对象进行信息隐藏。

封装是面向对象的特征之一，是对象和类概念的主要特性。简单地说，一个类就是一个封闭了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可是私有的，不能被外界访问，通过这种方式，对象对内部数据提供了不同级别的你别

优点：封闭能够灵活地对外隐藏内部信息，使代码模块化，更安全。

**继承**

定义：继承是指这样一种能力，它可以使用现有类的所有功能，并在无需重新编写原来的类的怀着下对这些功能进行扩展。

继承概念的实现方式有二类：实现继承与接口继承。实现继承是批直接使用基类的属性和方法而无需额外的能力；接口继承是批公使用属性和方法的名称、但是子类必须提供实现的能力；

优点：代码的复用

**多态**

定义：所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。

多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。

优点：接口的复用

#### 面向对象的五大原则

**单一职责原则**（Single-Responsibility Principle）

核心思想：一个类，最好只做一件事，只有一个引起它的变化。

单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。

开放封闭原则（Open-Closed principle）

核心思想：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。

开放封闭原则主要体现在两个方面：

- 1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
- 2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。 

实现开闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。

**Liskov替换原则**（Liskov-Substitution Principle）

核心思想：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

**依赖倒置原则**（Dependency-Inversion Principle）

核心思想：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 

我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

**接口隔离原则**（Interface-Segregation Principle）

其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”

#### 重写与重载

- **重载**：重载就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数期末考方法之间，互相称之为重载函数或者方法。
- **重写**：重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

#### 重载与重写的区别

| 重载                                                         | 重写                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 编译期的概念                                                 | 进行期的概念                                                 |
| 编译期绑定，即在编译时根据参数变量的类型判断应该调用哪个方法 | 运行时绑定，即在运行的时候根据引用变量所指向的实际对象的类型来调用方法 |

因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）。

#### 重写与重载的条件

| 重载                                       | 重写                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 被重载的方法必须改变参数列表               | 参数列表必须完全与被重写方法的相同                           |
| 被重载的方法可以改变返回类型               | 返回类型必须完全与被重写方法的返回类型相同                   |
| 被重载的方法可以改变访问修饰符             | 访问级别的限制性一定不能比被重写方法的强                     |
| 方法能够在同一个类中或者在一个子类中被重载 | 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常 |
| 被重载的方法可以声明新的或更广的检查异常   | 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明） |
| 方法能够在同一个类中或者在一个子类中被重载 | 如果不能继承一个方法，则不能重写这个方法                     |
| 与是否为 final 无关                        | 不能重写被标示为final的方法                                  |

#### 面向对象的复用技术

本节主要介绍组合和继承的概念及区别，并分析在写代码时如何进行选择。

**继承**

继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、你接口）的功能，并可以增加它自己的新功能的能力，继承 是类与类或者接口与接口之间最常见的郑敏继承是一种 *is a* 关系。

**组合**

组合（Composition）体现的是整体与部分、拥有的关系，即 has-a 的关系。

继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。--《Java编程思想》

只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。--《Effective Java》

#### 组合的优点

1. 不破坏封装，整体类与局部类之间松耦合，彼此相对独立

2. 具有较好的可扩展性
3. 支持动态组合。在运行时，整体对象可以选择不同类型的局部对象
4. 整体类可以对局部类进行包装，封装局部类的接口，提供新的接口
5. 整体类不能自动获得和局部类同样的接口
6. 创建整体类的对象时，需要创建所有局部类的对象
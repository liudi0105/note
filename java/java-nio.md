# Java NIO

## 阻塞 IO 与非阻塞 IO

### 阻塞 IO

通常在进行同步 I/O 操作时，如果读取数据，代码会阻塞直至有可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的 Server/Client 模式会基于 TPR（Thread per Request）,服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这由带来了新的问题，如果线程池中有 200 个线程，而有 200 个用户都在进行大文件下载，会导致第 201 个用户的请求无法及时处理，即便第 201 个用户只想请求一个几 KB 大小的页面。传统的 Server/Client 模式如下图所示：

### 非阻塞 IO（NIO）

NIO 中非阻塞 I/O 采用了基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，相反是注册感兴趣的特定 I/O 事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地 方，而且当那些事件发生时，就是这个对象告诉我们所发生的事件

## NIO 原理及通信模型

Java NIO 是在 jdk1.4 开始使用的，它既可以说成“New IO”，也可以说成“Non Blocking IO”。下面是 java NIO 的工作原理：

1. 由一个专门的线程来处理所有的 IO 事件，并负责分发。
2. 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
3. 线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。

Java NIO 的服务端只需启动一个专门的线程来处理所有的 IO 事件，这种通信模型是怎么实现的呢？呵呵，我们一起来探究它的奥秘吧。java NIO 采用了双向通道（channel）进行数据传输，而不是单向的流（stream），在通道上可以注册我们感兴趣的事件。一共有以下四种事件：

| 事件名                   | 对应值                     |
| ------------------------ | -------------------------- |
| 服务端接收客户端连接事件 | SelectionKey.OP_ACCEPT(16) |
|                          |
| 客户端连接服务端事件     | SelectionKey.OP_CONNECT(8) |
|                          |
| 读事件                   | SelectionKey.OP_READ(1)    |
| 写事件                   | SelectionKey.OP_WRITE(4)   |

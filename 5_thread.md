#### 什么是线程？

线程是操作系统能够进行运算高度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。

#### 线程和进程的区别？

一个进程是一个独立（self contained）的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有多个线程，每条线程并行执行不同的任务。**不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。**不能把它和栈内存搞混了，每个线程都拥有单独的内存用来存储本地数据。

#### 如何的 Java 中新建一个线程？

有两种创建线程的方法

1. 实现 Runnable 接口，然后将它传递给 Thread 的构造函数，创建一个 Thread 对象
2. 直接继承 Thread 类。

#### Thread 类中的 start() 和 run() 方法有什么区别？

start() 方法是被用来齐心协力新创建的线程，使该被创建的线程状态变为可运行状态。当你调用 run() 方法的时候，只会是在原来的线程中调用，没有新的线程启动。start() 方法才会启动新线程。如果我们调用了 Thread 的 run() 方法，它的行为应付和普通的方法一样，直接运行 run() 方法。为了在新的线程中执行我们的代码，必须使用 Thread.start() 方法。

#### Runnable 和 Callable 有什么区别？

Runnable 和 Callable 都代表那些要在不同的线程中执行的任务。Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5增加的。它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法则没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。

#### Java 中什么是竞态条件

当两个线程兑争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。界区实现方法有两种，一种是用 synchronized，一种是用 Lock 显式锁实现。

#### Java中的 volatile 变量是什么？

volatile 是一个特殊的修饰符，只有成员变量才能使用它。在 Java 并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile 变量可以保证下一个读取操作会在前一个写操作之后 发生。线程都会直接从内存中读取该变量并且不缓存它。

#### 什么是线程安全？

代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期一样，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被 多个线程使用的情况下也不会出现计算失误。

#### 一个线程运行时发生异常会怎样？

如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获 异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler() 来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException() 方法进行处理。

#### 如何在两个线程间共享数据？

你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。

#### Java 中 notify 和 notifyAll 有什么区别？

这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员撮合了一些方法当等待锚固件改变的时候通知它们，但是这些方法没有完全实现。notify() 方法不能唤醒七个具体的线程，所以只有一个线程在等待的时候它都有用武之地。而 notifyAll() 唤醒所有线程并允许它们争夺锁确保了至少有一个线程能继续运行。

#### 为什么 wait，notify 和 notifyAll 这些方法不在 thread 类里面？

一个很明显 的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁，那么调用对象中的 wait() 方法就有意义 了。如果 wait() 方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把它们定义在 Object 类中因为锁属于对象。

#### 什么是 ThreadLocal 变量？

ThreadLocal 是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal，就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。

#### 什么是 FutureTask？

在 Java 并发程序中，FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未不完成，get() 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask也是调用了 Runnable 接口，所以提交给 Executor 来执行。

#### Thread 的 interrupted() 和 isInterrupted() 方法有什么区别？

前者会将中断状态清除，后者不会。Java 多线程的中断机制是用内部标识来实现的，调用 Thread.interrupt() 来中断一个目标线程应付设置中断标识为 true。当中断线程调用静态方法 Thread.interrupted() 来检查中断状态时，中断状态会被清零。而非静态方法 isInterrupted() 用来查询其它线程的中断状态且不会改变中断状态标识。简单地说就是任何招聘 InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有可能被其他线程调用中断来改变。

#### 为什么 wait 和 notify 方法要在同步代码块中调用？

当一个线程需要调用对象的 wait() 方法的时候，这个线程必须拥有该对象的锁，接着它就 会释放这个 对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify() 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。如果不这么做，代码会抛出 IllegalMonitorStateException 异常。

#### 什么是线程池？它的优点是什么？

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从 JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。

#### 如何写代码来解决生产都消费者问题？

在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务代其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用 wait() 和 notify() 来解决这个问题，比较赞的办法是用 Semaphore 或者 BlockingQueue 来实现生产者消费者模型。

#### 什么是死锁？

死锁同是批两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务

#### 死锁发生的条件

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的线程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

#### Java 中活锁和死锁有什么区别？

活锁的线程或进程的状态是不断改变的，鋈没可以认为是一种特殊的饥饿。一个现实的
# 线程

## 线程基础

### 什么是线程？

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。

### 线程和进程有什么区别？

一个进程是一个独立（self contained）的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有多个线程，每条线程并行执行不同的任务。**不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。**不能把它和栈内存搞混了，每个线程都拥有单独的内存用来存储本地数据。

### 什么是临界区和竞态条件

竞态条件是在临界区内可能发生的一种特殊情况。临界区是多线程并发执行一代码，根据线程的执行顺序可能产生多种结果的区域。多线程在临界区执行代码的结果可能不一样，不同的结果取决于线程的执行顺序。也就是说，临界区包含竞态条件。竞态一词源于隐喻，线程在临界区进进行资源竞争，在临界区的资源竞争影响最后的结果。

### 什么是线程安全？

代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期一样，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被 多个线程使用的情况下也不会出现计算失误。

### 一个线程运行时发生异常会怎样？

如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获 异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler() 来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException() 方法进行处理。

### 如何在两个线程间共享数据？

你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。

### 什么是 FutureTask？

在 Java 并发程序中，FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未不完成，get() 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask也是调用了 Runnable 接口，所以提交给 Executor 来执行。

### 什么是线程池？它的优点是什么？

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从 JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。

### 如何写代码来解决生产都消费者问题？

在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务代其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用 wait() 和 notify() 来解决这个问题，比较赞的办法是用 Semaphore 或者 BlockingQueue 来实现生产者消费者模型。

### 什么是死锁？

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于*死锁*状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁发生的条件

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的线程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

### Java 中 notify 和 notifyAll 有什么区别？

这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员撮合了一些方法当等待锚固件改变的时候通知它们，但是这些方法没有完全实现。notify() 方法不能唤醒七个具体的线程，所以只有一个线程在等待的时候它都有用武之地。而 notifyAll() 唤醒所有线程并允许它们争夺锁确保了至少有一个线程能继续运行。

### 为什么 wait()，notify() 和 notifyAll() 这些方法在 Object 中？

Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁，那么调用对象中的 wait() 方法就有意义 了。如果 wait() 方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把它们定义在 Object 类中因为锁属于对象。

### 为什么 wait() 和 notify() 方法要在同步块中调用？

wait() 方法做了两件事，一是释放锁，二是使当前线程处于等待状态。若要释放锁先要获取锁，在同步块中是持有锁的状态，因此要在同步块中执行 wait()。

notify() 方法通知持有当前锁时 wait() 的线程继续执行，因此也需要先获取锁。

### 为什么 wait 和 notify 方法要在同步代码块中调用？

当一个线程需要调用对象的 wait() 方法的时候，这个线程必须拥有该对象的锁，接着它就 会释放这个 对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify() 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。如果不这么做，代码会抛出 IllegalMonitorStateException 异常。

## 线程池

### 什么是线程池

线程池的基本思想是一种对象池，在程序启动时就开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。

### 使用线程池的好处

1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 运用线程池能有效的控制线程最大并发数，可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
3. 对线程进行一些简单的管理，比如：延时执行、定时循环执行的策略等，运用线程池都能进行很好的实现

### 线程池的主要组件

1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
2. 工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
3. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
4. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。